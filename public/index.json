
[{"content":"","date":"26 October 2025","externalUrl":null,"permalink":"/","section":"Aero Blog","summary":"","title":"Aero Blog","type":"page"},{"content":" Challenge Description # The developer of the Flag management system seems to have implanted a backdoor into this system. As a tester, can you find the backdoor and obtain the flag? Given information # We are working with a truncated LCG which outputs its lsb bits via the vcode var. We are additionally give the modulus (p), increment (b) and the multiplier (a).\nAnalysis # The prng is called 32 times because of this one line : sha256((\u0026quot;\u0026quot;.join(prng.choices(ascii_letters + digits, 32))).encode()).hexdigest() for constructing the admin\u0026rsquo;s password The actual outputs are given as prng.randbytes(4) which internally calls the prng with prng.next() % 256 4 times and gives the outputs as bytes. Upon logging in as admin after performing a state recovery on the prng, we get the key, iv which are generated by prng.randbytes(16) and then we also get the flag as the ciphertext. Approach # Very standard lattice attack case except working with lsb, I personally spent a lot of time reading lsb-msb calc game blog by Joseph and then tweaking jvdsn\u0026rsquo;s script for the msb case. Grok gave me a state transformation variation of the script where each state is transformed as: $$s_{i} \\equiv x_{i} \\cdot 2^{-8} \\bmod p$$ where $x_{i}$ is the state and c is now: $$c^{'} \\equiv b\\cdot 2^{-8} \\bmod p $$ This yields a new LCG where our lsb bits are the msb and now we can feed to the existing attack script. There are certain edge cases with wrapping but grok was kind enough to do all of that. This gives us the state right after initial admin password generation, therefore requiring a simple rollback of 33 states. It is trivial as all the states are now known. We query the correct admin password generated by the prng and login, replicate the key and iv generation and finally aes cbc decrypt to get the flag. Solve script # from pwn import * import os import pty from Crypto.Util.number import * from Crypto.Util.Padding import unpad from Crypto.Cipher import AES from hashlib import sha256 from random import randrange from string import ascii_letters, digits from binascii import unhexlify from sage.all import QQ, ZZ, matrix, vector from fpylll import * class PRNG: def __init__(self, a=None, b=None, p=None, seed=None): self.p = p if p else getPrime(128) self.a = a if a else randrange(1, self.p) self.b = b if b else randrange(0, self.p) self.state = seed if seed else randrange(0, self.p) def next(self): self.state = (self.a * self.state + self.b) % self.p return self.state def randbytes(self, n): out = b\u0026#39;\u0026#39; for _ in range(n): out += bytes([self.next() % 256]) return out def choices(self, seq, k): return [seq[self.next() % len(seq)] for _ in range(k)] def getPrime(self, n): while True: num = self.randbytes(n // 8) p = bytes_to_long(num) | (1 \u0026lt;\u0026lt; (n - 1)) | 1 if isPrime(p): return p def getrandbits(self, n): num = self.randbytes((n + 7) // 8) return bytes_to_long(num) \u0026amp; ((1 \u0026lt;\u0026lt; n) - 1) def __repr__(self): return f\u0026#39;a = {self.a}\\nb = {self.b}\\np = {self.p}\u0026#39; def go_backward(state, steps, a, b, p): inv_a = pow(a,-1, p) s = state for _ in range(steps): s = (inv_a * (s - b)) % p return s def attack(y_msb, k, s, m, a, c): \u0026#34;\u0026#34;\u0026#34; Fixed lattice attack for MSB-truncated LCG with non-zero increment. Uses ~ t = len(y_msb) \u0026gt;= 2*s samples for reliability. \u0026#34;\u0026#34;\u0026#34; t = len(y_msb) diff_bits = k - s y = vector(ZZ, y_msb) delta = ZZ(0) for i in range(t): y[i] = (y[i] * (ZZ(1) \u0026lt;\u0026lt; diff_bits) - delta) % m delta = (a * delta + c) % m B = matrix(ZZ, t, t) B[0, 0] = m for i in range(1, t): B[i, 0] = pow(a, i, m) B[i, i] = ZZ(-1) B = B.LLL() b_vec = B * y for i in range(t): b_vec[i] = round(QQ(b_vec[i]) / m) * m - b_vec[i] errors = B.solve_right(b_vec) x_hom = [int(y[i] + errors[i]) for i in range(t)] delta = ZZ(0) x = [] for i in range(t): xi = (x_hom[i] + delta) % m x.append(int(xi)) delta = (a * delta + c) % m return x io = remote(\u0026#34;pwn-ce8ba3d260.challenge.xctf.org.cn\u0026#34;, 9999, ssl=True) sa = lambda x: io.sendlineafter(b\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;, x.encode()) sa(\u0026#34;G\u0026#34;) a = int(io.recvline().decode().strip().partition(\u0026#39;= \u0026#39;)[-1]) b = int(io.recvline().decode().strip().partition(\u0026#39;= \u0026#39;)[-1]) p = int(io.recvline().decode().strip().partition(\u0026#39;= \u0026#39;)[-1]) cnt = 25 collect = [] for i in range(cnt): sa(\u0026#34;L\u0026#34;) user = \u0026#39;\u0026#39;.join(random.choices(string.ascii_letters, k=8)).encode() io.recvuntil(b\u0026#34;: \u0026#34;) vcode_hex = io.recvline().decode().strip() vcode = bytes_to_long(unhexlify(vcode_hex)) io.sendlineafter(b\u0026#39;Username: \u0026#39;, user) io.sendlineafter(b\u0026#39;Password: \u0026#39;, user) io.sendlineafter(b\u0026#34;Verification code: \u0026#34;, vcode_hex.encode()) ss = [int(j) for j in long_to_bytes(vcode)] collect.append(ss) fss = [x for sublist in collect for x in sublist] print(f\u0026#34;Leaks: {fss}\u0026#34;) ## Grok stuff for a while # LSB -\u0026gt; MSB transform s_bit = 8 k_bit = 128 I = pow(1 \u0026lt;\u0026lt; s_bit,-1, p) c_prime = (b * I) % p msb_list = [] for yl in fss: g = (yl * I) % p msb = g \u0026gt;\u0026gt; (k_bit - s_bit) msb_list.append(msb) print(f\u0026#34;Transformed MSBs: {msb_list}\u0026#34;) # Recover S states S_states = attack(msb_list, k_bit, s_bit, p, a, c_prime) print(\u0026#34;Recovered S:\u0026#34;, S_states) # Back to X X_states = [(S * (1 \u0026lt;\u0026lt; s_bit)) % p for S in S_states] print(\u0026#34;Recovered X:\u0026#34;, X_states) # Verify (should all match; rare mismatch? re-run with cnt+=1) matches = [X % 256 == leak for X, leak in zip(X_states, fss)] print(\u0026#34;Matches:\u0026#34;, matches) print([x % 256 for x in X_states]) print(fss) if not all(matches): print(\u0026#34;Rare wrap; increase cnt and re-run.\u0026#34;) ## Grok stuff ends here steps_to_initial = 33 s0 = go_backward(X_states[0], steps_to_initial, a, b, p) prng_pass = PRNG(a=a, b=b, p=p, seed=s0) seq = ascii_letters + digits pass_str = \u0026#39;\u0026#39;.join(prng_pass.choices(seq, 32)) admin_hash = pass_str.encode() print(f\u0026#34;Admin hash: {admin_hash}\u0026#34;) prng_key = PRNG(a=a, b=b, p=p, seed=X_states[-1]) sa(\u0026#39;L\u0026#39;) io.recvuntil(b\u0026#34;: \u0026#34;) vcode_hex = io.recvline().decode().strip() prng_key.randbytes(4) # Local advance io.sendlineafter(b\u0026#39;Username: \u0026#39;, b\u0026#39;admin\u0026#39;) io.sendlineafter(b\u0026#39;Password: \u0026#39;, admin_hash) io.sendlineafter(b\u0026#34;Verification code: \u0026#34;, vcode_hex.encode()) sa(\u0026#34;R\u0026#34;) key = prng_key.randbytes(16) iv = prng_key.randbytes(16) ct_hex = io.recvline().strip().decode() ct = unhexlify(ct_hex) aes = AES.new(key, AES.MODE_CBC, iv) pt = unpad(aes.decrypt(ct), 16) print(\u0026#34;Flag:\u0026#34;, pt.decode()) io.close() ","date":"26 October 2025","externalUrl":null,"permalink":"/posts/fms/","section":"Posts","summary":"","title":"Cybermimic Defense 2025 Crypto - FMS","type":"posts"},{"content":"","date":"26 October 2025","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":" Challenge Description # This is a sketch of a cryptosystem, nothing makes sense but some claim it is secure, show them what you got Given information # We are given the modulus N, leak which is shuffle_chunk(p, x) ^ shuffle_chunk(q, y), cei_ce_au_valoarea, sefu_la_bani, k, ciphertext and the Narnia outputs from the seeds given by the user.\nAnalysis # Starting with generate_random_shuffle() it seeded using either seedx or seedy in the server and just returns a list after flattening each sublist within the mainlist after randomly shuffling the elements within the given split range. shuffle_chunk() takes an int, shuffles the bits based on the shuffling array that is provided which is x and y. narnia() takes the secret which is either seedx or seedy, xors it with an 5 lists which are generated by each of the seeds and randomly shuffled using a number from a CSPRNG. Each of the lists contain 17 integers as the last three integers after shuffling are not considered for xoring. Approach # Any sort of MITM approach felt like it would be too computationally expensive so we went with the following: Find 5 seeds such that each one of them generates a 0 at a specific bit position which when fed into the narnia() func would leak exactly one bit of information from the secret which is either seedx or seedy. As the server permits 42 tries, we can query 21 times for seedx and do the same for seedy revealing a total of 21 lsb in both. Now as seedx and seedy are 32 bit values, we can brute 2^11 * 2^11 and verify using the given cei_ce_au_valoarea. Now that x and y are revealed, we use branch and prune to find the appropriate bits of p and q and then perform RSA decryption to get flag. TLDR: z3 might work for the last step but could not get it working. Also AI helped quite a lot :)\nSolve script # from typing import List, Tuple, Optional from pwn import * from Crypto.Util.number import long_to_bytes,bytes_to_long, inverse BITS = 512 def generate_random_shuffle(seed, splits): random.seed(seed) lst = list(range(BITS)) caca = [lst[j:j+splits] for j in range(0,len(lst),splits)] for chunk in caca: random.shuffle(chunk) return [caca for sublist in caca for caca in sublist] def shuffle_chunk(x, shuffle_arr): res = 0 for i in range(BITS): bit = (x \u0026gt;\u0026gt; i) \u0026amp; 1 res |= bit \u0026lt;\u0026lt; shuffle_arr[i] return res def inverse_perm(perm: List[int]) -\u0026gt; List[int]: inv = [0] * len(perm) for i, t in enumerate(perm): inv[t] = i return inv def branch_and_prune_factor( n: int, leak: int, inv_x: List[int], inv_y: List[int], ) -\u0026gt; Optional[Tuple[int, int]]: assert len(inv_x) == BITS and len(inv_y) == BITS leak_bits = [(leak \u0026gt;\u0026gt; j) \u0026amp; 1 for j in range(BITS)] by_when = [[] for _ in range(BITS)] for j in range(BITS): a = inv_x[j] b = inv_y[j] t = a if a \u0026gt;= b else b by_when[t].append((a, b, leak_bits[j])) live_constraints: List[Tuple[int, int, int]] = [] candidates = {(0, 0)} n_low = 0 mask = 0 for bit_pos in range(BITS): mask = (mask \u0026lt;\u0026lt; 1) | 1 n_low = n \u0026amp; mask live_constraints.extend(by_when[bit_pos]) new_candidates = set() if bit_pos == 0: base_branches = [(1, 1)] else: base_branches = [(0, 0), (0, 1), (1, 0), (1, 1)] for (p_mod, q_mod) in candidates: for bp, bq in base_branches: np = p_mod | (bp \u0026lt;\u0026lt; bit_pos) nq = q_mod | (bq \u0026lt;\u0026lt; bit_pos) if (np * nq) \u0026amp; mask != n_low: continue ok = True for (a, b, lb) in live_constraints: xb = (np \u0026gt;\u0026gt; a) \u0026amp; 1 yb = (nq \u0026gt;\u0026gt; b) \u0026amp; 1 if (xb ^ yb) != lb: ok = False break if ok: new_candidates.add((np, nq)) candidates = new_candidates if not candidates: return None for p, q in candidates: if p * q == n: return (p, q) return None def brute_force_seeds(partial_seedx, partial_seedy, known_mask_x, known_mask_y, sefu_la_bani, cei_ce_au_valoarea, k): # Assuming partial_seedx has the known bits set, and known_mask_x has 1s where bits are known for seedx # Similarly for seedy # Missing bits are where mask == 0, and we brute-force those (assuming exactly 11 missing bits each) for missing_x in range(1 \u0026lt;\u0026lt; 11): seedx = partial_seedx bit_pos = 0 temp_missing = missing_x for i in range(32): if not (known_mask_x \u0026amp; (1 \u0026lt;\u0026lt; i)): seedx |= ((temp_missing \u0026amp; 1) \u0026lt;\u0026lt; i) temp_missing \u0026gt;\u0026gt;= 1 x = generate_random_shuffle(seedx, 13) for missing_y in range(1 \u0026lt;\u0026lt; 11): seedy = partial_seedy bit_pos = 0 temp_missing = missing_y for i in range(32): if not (known_mask_y \u0026amp; (1 \u0026lt;\u0026lt; i)): seedy |= ((temp_missing \u0026amp; 1) \u0026lt;\u0026lt; i) temp_missing \u0026gt;\u0026gt;= 1 y = generate_random_shuffle(seedy, 7) sum_val = 0 for i in range(16): term = sefu_la_bani[i] * (x[8 * i] + 2) * (y[i] + 2) sum_val = (sum_val + term) % k if sum_val == cei_ce_au_valoarea: return seedx, seedy return None, None seeds = [[54592, 589806, 691520, 1511525, 1907923], [1456373, 1762619, 3246281, 5898661, 6776965], [405895, 765898, 2571370, 4198869, 4610898], [742525, 2854984, 3080733, 4055808, 4442376], [390601, 983414, 3571289, 3735060, 5195484], [3079153, 4063973, 5494148, 6770235, 7589131], [1494392, 2187565, 4192009, 7161644, 8169314], [2279714, 3489277, 4129676, 4528152, 4685760], [4481993, 4907857, 7193330, 7621171, 7799985], [2232206, 3754434, 3981656, 4144095, 4383087], [755696, 914511, 1948828, 2026807, 3404297], [405497, 2219856, 2829986, 4139443, 4929177], [764282, 1768025, 3857687, 4039875, 6159752], [1626263, 5334703, 7056022, 7491980, 10232369], [623324, 2611090, 2726712, 3023155, 3969667], [2120530, 2373027, 2925202, 3192740, 4112071], [849566, 1782321, 3684491, 5440985, 6447854], [246366, 1472630, 3757499, 5417180, 6533879], [2899292, 3895269, 6262368, 6541294, 6772557], [1847954, 4937715, 6414473, 6886687, 7198114], [336133, 2430365, 4725975, 4944450, 7272566]] p = remote(\u0026#39;35.198.141.47\u0026#39; ,31081) # Change to challenge host/port p.sendline(b\u0026#34;get_data\u0026#34;) p.recvuntil(b\u0026#34;n = \u0026#34;) n = int(p.recvline().strip()) p.recvuntil(b\u0026#34;leak = \u0026#34;) leak = int(p.recvline().strip()) p.recvuntil(b\u0026#34;sefu_la_bani = \u0026#34;) sefu_la_bani = eval(p.recvline().strip()) p.recvuntil(b\u0026#34;cei_ce_au_valoarea = \u0026#34;) cei_ce_au_valoarea = int(p.recvline().strip()) p.recvuntil(b\u0026#34;k = \u0026#34;) k = int(p.recvline().strip()) p.recvuntil(b\u0026#34;ct = \u0026#34;) ct = int(p.recvline().strip()) log.info(f\u0026#34;n = {n}\u0026#34;) log.info(f\u0026#34;ct = {ct}\u0026#34;) acc = 0 for attempt in range(21): p.sendline(f\u0026#34;query x {\u0026#39; \u0026#39;.join(map(str, seeds[attempt]))}\u0026#34;.encode()) p.recvuntil(b\u0026#34;Output: \u0026#34;) val = int(p.recvline().strip()) val \u0026amp;= 0xffffffff # force 32-bit domain, just in case bit_k = (val \u0026gt;\u0026gt; attempt) \u0026amp; 1 acc |= (bit_k \u0026lt;\u0026lt; attempt) lowx = acc acc = 0 for attempt in range(21): p.sendline(f\u0026#34;query y {\u0026#39; \u0026#39;.join(map(str, seeds[attempt]))}\u0026#34;.encode()) p.recvuntil(b\u0026#34;Output: \u0026#34;) val = int(p.recvline().strip()) val \u0026amp;= 0xffffffff # force 32-bit domain, just in case bit_k = (val \u0026gt;\u0026gt; attempt) \u0026amp; 1 acc |= (bit_k \u0026lt;\u0026lt; attempt) lowy = acc log.info(f\u0026#34;Lower 21 bits seedx = {lowx}\u0026#34;) log.info(f\u0026#34;Lower 21 bits seedy = {lowy}\u0026#34;) seedx, seedy = brute_force_seeds(lowx, lowy, (1\u0026lt;\u0026lt;21)-1, (1\u0026lt;\u0026lt;21)-1, sefu_la_bani, cei_ce_au_valoarea, k) log.info(f\u0026#34;Found seedx = {seedx}\u0026#34;) log.info(f\u0026#34;Found seedy = {seedy}\u0026#34;) if not seedx or not seedy: log.error(\u0026#34;Failed to find valid seeds\u0026#34;) exit() x = generate_random_shuffle(seedx, 13) y = generate_random_shuffle(seedy, 7) p_val, q_val = branch_and_prune_factor(n, leak, inverse_perm(x), inverse_perm(y)) if p_val and q_val: log.info(f\u0026#34;p = {p_val}\u0026#34;) log.info(f\u0026#34;q = {q_val}\u0026#34;) e = 65537 phi = (p_val - 1) * (q_val - 1) d = inverse(e, phi) m = pow(ct, d, n) flag = long_to_bytes(m) log.success(f\u0026#34;Flag: {flag.decode()}\u0026#34;) p.close() Flag : CTF{w0w_you_actually_deciphered_the_blueprint_sorry_it_took_so_long_had_to_patch_unintendeds_skibidi_have_fun_with_the_rest}\n","date":"14 September 2025","externalUrl":null,"permalink":"/posts/blueprint/","section":"Posts","summary":"","title":"Defcamp 2025 Crypto - Blueprint","type":"posts"},{"content":" Challenge Description # \u0026#34;You hunger to claim victory in a war that ended without you.\u0026#34; Introduction # This is the challenge I made for bi0sCTF 2025. I wanted to make an EHNP instance challenge for sometime now so I made it with some Ultrakill theme\nGiven information # chall.py # from tinyec.ec import SubGroup, Curve from RMT import R_MT19937_32bit as special_random from decor import HP, death_message, menu_box, title_drop from Crypto.Util.number import bytes_to_long as b2l from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Random.random import getrandbits from hashlib import sha256 from json import loads import sys import os from secret import FLAG CORE = 0xb4587f9bd72e39c54d77b252f96890f2347ceff5cb6231dfaadb94336df08dfd class _1000_THR_Signing_System: def __init__(self): # secp256k1 self.p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f self.a = 0x0000000000000000000000000000000000000000000000000000000000000000 self.b = 0x0000000000000000000000000000000000000000000000000000000000000007 self.Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798 self.Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8 self.n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 self.h = 0x1 subgroup = SubGroup(self.p, (self.Gx, self.Gy), self.n, self.h) self.curve = Curve(self.a, self.b, subgroup, name=\u0026#34;CustomCurve\u0026#34;) self.cinit = 0 self.d = self.privkey_gen() self.P = self.curve.g self.Q = self.d * self.P self.Max_Sec = special_random(getrandbits(32)) def sec_real_bits(self,bits: int) -\u0026gt; int: if bits % 32 != 0: raise ValueError(\u0026#34;Bit length must be a multiple of 32\u0026#34;) exp = bits // 32 x = self.Max_Sec.get_num() ** exp cyc_exhausted = 0 while x.bit_length() != bits: x = self.Max_Sec.get_num() ** exp cyc_exhausted += 1 return (x, cyc_exhausted) @staticmethod def real_bits(bits) -\u0026gt; int: x = getrandbits(bits) while x.bit_length() != bits: x = getrandbits(bits) return x @staticmethod def supreme_RNG(seed: int, length: int = 10): while True: str_seed = str(seed) if len(str(seed)) % 2 == 0 else \u0026#39;0\u0026#39; + str(seed) sqn = str(seed**2) mid = len(str_seed) \u0026gt;\u0026gt; 1 start = (len(sqn) \u0026gt;\u0026gt; 1) - mid end = (len(sqn) \u0026gt;\u0026gt; 1) + mid yield sqn[start : end].zfill(length) seed = int(sqn[start : end]) def restart_level(self): print(\u0026#34;S T A R T I N G R O U T I N E . . .\\n\u0026#34;) self.Max_Sec = special_random(getrandbits(32)) self.d = self.privkey_gen() self.P = self.curve.g self.Q = self.d * self.P def sign(self, msg: bytes) -\u0026gt; tuple: k, n1, n2, cycles = self.full_noncense_gen() # 全くナンセンスですが、日本語では kG = k * self.P r = kG.x % self.n k = k % self.n Hmsg = sha256() Hmsg.update(msg) s = ((b2l(Hmsg.digest()) + r * self.d) * pow(k, -1, self.n)) % self.n return (r, s, n1, n2, cycles) def partial_noncense_gen(self,bits: int, sub_bits: int, shift: int) -\u0026gt; int: term = self.real_bits(bits) _and = self.real_bits(bits - sub_bits) equation = term ^ ((term \u0026lt;\u0026lt; shift) \u0026amp; _and) return (term,_and,equation) def full_noncense_gen(self) -\u0026gt; tuple: k_m1 = self.real_bits(24) k_m2 = self.real_bits(24) k_m3 = self.real_bits(69) k_m4 = self.real_bits(30) k_, cycle_1 = self.sec_real_bits(32) _k, cycle_2 = self.sec_real_bits(32) benjamin1, and1, eq1 = self.partial_noncense_gen(32, 16, 16) benjamin2, and2, eq2 = self.partial_noncense_gen(32 ,16 ,16) const_list = [k_m1, (benjamin1 \u0026gt;\u0026gt; 24 \u0026amp; 0xFF), k_m2, (benjamin1 \u0026gt;\u0026gt; 16 \u0026amp; 0xFF) , k_, (benjamin1 \u0026gt;\u0026gt; 8 \u0026amp; 0xFF), k_m3, (benjamin1 \u0026amp; 0xFF), k_m4, (benjamin2 \u0026gt;\u0026gt; 24 \u0026amp; 0xFFF), _k] shift_list = [232, 224, 200, 192, 160, 152, 83, 75, 45, 33, 0] n1 = [and1, eq1] n2 = [and2, eq2] cycles = [cycle_1, cycle_2] noncense = 0 for const, shift in zip(const_list, shift_list): noncense += const \u0026lt;\u0026lt; shift return noncense, n1, n2, cycles def privkey_gen(self) -\u0026gt; int: simple_lcg = lambda x: (x * 0xeccd4f4fea74c2b057dafe9c201bae658da461af44b5f04dd6470818429e043d + 0x8aaf15) % self.n if not self.cinit: RNG_seed = simple_lcg(CORE) self.n_gen = self.supreme_RNG(RNG_seed) RNG_gen = next(self.n_gen) self.cinit += 1 else: RNG_gen = next(self.n_gen) p1 = hex(self.real_bits(108)) p2 = hex(self.real_bits(107))[2:] priv_key = p1 + RNG_gen[:5] + p2 + RNG_gen[5:] return int(priv_key, 16) def gen_encrypted_flag(self) -\u0026gt; tuple: sha2 = sha256() sha2.update(str(self.d).encode(\u0026#39;ascii\u0026#39;)) key = sha2.digest()[:16] iv = os.urandom(16) cipher = AES.new(key, AES.MODE_CBC, iv) ciphertext = cipher.encrypt(pad(FLAG, 16)) return (ciphertext.hex(), iv.hex()) def _dead_coin_params(self) -\u0026gt; tuple: base = 2 speed = getrandbits(128) feedbacker_parry = int(next(self.n_gen)) style_bonus = feedbacker_parry ^ (feedbacker_parry \u0026gt;\u0026gt; 5) power = pow(base, style_bonus, speed) return (power, speed, feedbacker_parry) def deadcoin_verification(self, tries): if tries \u0026lt; 3: print(f\u0026#34;Successfully perform a {\u0026#34;\\33[33m\u0026#34;}deadcoin{\u0026#34;\\33[0m\u0026#34;} and perform a {\u0026#34;\\33[34m\u0026#34;}feedbacker{\u0026#34;\\33[0m\u0026#34;} parry for getting {\u0026#34;\\33[1;91m\u0026#34;}BLOOD{\u0026#34;\\33[0m\u0026#34;} to survive.\\n\u0026#34;) power, speed, feedbacker_parry = self._dead_coin_params() print(f\u0026#34;Calculated power and speed for the number - {tries+1} deadcoin: {power, speed}\u0026#34;) try: action_code = int(input(\u0026#34;Action code: \u0026#34;)) if action_code == feedbacker_parry: blood = self.Max_Sec.get_num() print(f\u0026#34;[+ FISTFUL OF DOLLAR]\u0026#34;) print(f\u0026#34;Here\u0026#39;s some {\u0026#34;\\33[1;91m\u0026#34;}BLOOD{\u0026#34;\\33[0m\u0026#34;} - ID: {blood}\u0026#34;) return True else: print(\u0026#34;Missed.\u0026#34;) except: print(\u0026#34;Invalid action code\u0026#34;) else: print(\u0026#34;You\u0026#39;re done.\u0026#34;) return False class _1000_THR_EARTHMOVER: def __init__(self): self.Boss = _1000_THR_Signing_System() def get_encrypted_flag(self): ciphertext, iv = self.Boss.gen_encrypted_flag() return {\u0026#34;ciphertext\u0026#34;: ciphertext,\u0026#34;iv\u0026#34;: iv} def perform_deadcoin(self, tries): return self.Boss.deadcoin_verification(tries) def call_the_signer(self): msg = input(\u0026#34;What do you wish to speak? \u0026#34;).encode() r, s, n1, n2, cycles = self.Boss.sign(msg) return {\u0026#34;r\u0026#34;: r, \u0026#34;s\u0026#34;: s, \u0026#34;nonce_gen_consts\u0026#34;: [n1, n2], \u0026#34;heat_gen\u0026#34;: cycles} def level_restart(self): self.Boss.restart_level() def level_quit(self): sys.exit() def main(): LEVEL = _1000_THR_EARTHMOVER() tries = 0 title_drop() V1 = HP(100,100, \u0026#34;V1\u0026#34;, HP.color_red) while True: try: menu_box() print(f\u0026#39;\\n{V1}\u0026#39;) move = loads(input(\u0026#34;\\nExpecting Routine in JSON format: \u0026#34;)) if \u0026#34;event\u0026#34; not in move: print({\u0026#34;Error\u0026#34;: \u0026#34;Unrecognised event\u0026#34;}) continue v1_action = move[\u0026#34;event\u0026#34;] survive = V1.check(v1_action) if not survive: death_message() break if v1_action == \u0026#34;get_encrypted_flag\u0026#34;: print(LEVEL.get_encrypted_flag()) V1.update(V1.current_health-50) elif v1_action == \u0026#34;perform_deadcoin\u0026#34;: verify = LEVEL.perform_deadcoin(tries) tries += 1 if verify: V1.update(V1.current_health+20) elif v1_action == \u0026#34;call_the_signer\u0026#34;: print(LEVEL.call_the_signer()) V1.update(V1.current_health-20) elif v1_action == \u0026#34;level_restart\u0026#34;: LEVEL.level_restart() V1.update(100) elif v1_action == \u0026#34;level_quit\u0026#34;: LEVEL.level_quit() else: pass except Exception: print({\u0026#34;Error\u0026#34;: \u0026#34;Unrecognised V1 action\u0026#34;}) if __name__ == \u0026#34;__main__\u0026#34;: main() Decor.py # # Place for the brainrot class HP: bars = 20 remaining_health_symbol = \u0026#34;█\u0026#34; lost_health_symbol = \u0026#34;░\u0026#34; color_green = \u0026#34;\\033[92m\u0026#34; color_yellow = \u0026#34;\\33[33m\u0026#34; color_red = \u0026#34;\\033[91m\u0026#34; color_default = \u0026#34;\\033[0m\u0026#34; def __init__(self, max_health, current_health, name, health_color): self.max_health = max_health self.current_health = current_health self.remaining_health_bars = round(self.current_health / self.max_health * HP.bars) self.lost_health_bars = HP.bars - self.remaining_health_bars self.health_color = health_color self.name = name def update(self, current): self.current_health = current self.remaining_health_bars = round(self.current_health / self.max_health * HP.bars) self.lost_health_bars = HP.bars - self.remaining_health_bars def check(self, move): move_cost_dict = {\u0026#34;get_encrypted_flag\u0026#34;: 50, \u0026#34;perform_deadcoin\u0026#34; : 0, \u0026#34;call_the_signer\u0026#34; : 20, \u0026#34;level_restart\u0026#34; : 0, \u0026#34;level_quit\u0026#34; : 0} if (self.current_health - move_cost_dict[move]) \u0026lt;= 0 : return False return True def __repr__(self): return f\u0026#34;Your HP : ❤ {\u0026#39;\\33[0;101m\u0026#39;}{self.current_health}{\u0026#39;\\33[0m\u0026#39;}\u0026#34;f\u0026#34;{self.health_color}{self.remaining_health_bars * self.remaining_health_symbol}\u0026#34;f\u0026#34;{self.lost_health_bars * self.lost_health_symbol}{HP.color_default}\u0026#34; def title_drop(): from time import sleep title_drop = f\u0026#39;\u0026#39;\u0026#39;{\u0026#34;\\33[1;91m\u0026#34;} ██╗ ██╗██╗ ██████╗ ██╗ ███████╗███╗ ██╗ ██████╗███████╗ ██╗ ██╗ ███████╗███╗ ██╗ ██████╗ ██████╗ ██████╗ ███████╗ ██║ ██║██║██╔═══██╗██║ ██╔════╝████╗ ██║██╔════╝██╔════╝ ██╔╝ ██╔╝ ██╔════╝████╗ ██║██╔════╝██╔═══██╗██╔══██╗██╔════╝ ██║ ██║██║██║ ██║██║ █████╗ ██╔██╗ ██║██║ █████╗ ██╔╝ ██╔╝ █████╗ ██╔██╗ ██║██║ ██║ ██║██████╔╝█████╗ ╚██╗ ██╔╝██║██║ ██║██║ ██╔══╝ ██║╚██╗██║██║ ██╔══╝ ██╔╝ ██╔╝ ██╔══╝ ██║╚██╗██║██║ ██║ ██║██╔══██╗██╔══╝ ╚████╔╝ ██║╚██████╔╝███████╗███████╗██║ ╚████║╚██████╗███████╗ ██╔╝ ██╔╝ ███████╗██║ ╚████║╚██████╗╚██████╔╝██║ ██║███████╗ ╚═══╝ ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝ ╚═══╝ ╚═════╝╚══════╝ ╚═╝ ╚═╝ ╚══════╝╚═╝ ╚═══╝ ╚═════╝ ╚═════╝ ╚═╝ ╚═╝╚══════╝ ██╗ ██╗██╗ ██╗███████╗ ██████╗ ██████╗ ███╗ ██╗ ██████╗ ███████╗ ████████╗ ██████╗ ██╗ ██╗███████╗ █████╗ ██╗ ██╗███████╗███╗ ██╗ ██║ ██║██║ ██╔╝██╔════╝ ██╔══██╗██╔══██╗████╗ ██║██╔════╝ ██╔════╝ ╚══██╔══╝██╔═══██╗ ██║ ██║██╔════╝██╔══██╗██║ ██║██╔════╝████╗ ██║ ██║ ██║█████╔╝ █████╗ ██████╔╝██████╔╝██╔██╗ ██║██║ ███╗███████╗ ██║ ██║ ██║ ███████║█████╗ ███████║██║ ██║█████╗ ██╔██╗ ██║ ██║ ██║██╔═██╗ ██╔══╝ ██╔═══╝ ██╔══██╗██║╚██╗██║██║ ██║╚════██║ ██║ ██║ ██║ ██╔══██║██╔══╝ ██╔══██║╚██╗ ██╔╝██╔══╝ ██║╚██╗██║ ██╗██╗██╗███████╗██║██║ ██╗███████╗ ██║ ██║ ██║██║ ╚████║╚██████╔╝███████║ ██║ ╚██████╔╝ ██║ ██║███████╗██║ ██║ ╚████╔╝ ███████╗██║ ╚████║ ╚═╝╚═╝╚═╝╚══════╝╚═╝╚═╝ ╚═╝╚══════╝ ╚═╝ ╚═╝ ╚═╝╚═╝ ╚═══╝ ╚═════╝ ╚══════╝ ╚═╝ ╚═════╝ ╚═╝ ╚═╝╚══════╝╚═╝ ╚═╝ ╚═══╝ ╚══════╝╚═╝ ╚═══╝ {\u0026#34;\\33[0m\u0026#34;}\u0026#39;\u0026#39;\u0026#39; print(title_drop) sleep(1.25) print(\u0026#34;S T A R T I N G R O U T I N E . . .\\n\u0026#34;) sleep(1) print(f\u0026#39;{\u0026#34;\\33[1;91m\u0026#34;}WARNING: INTRUDER DETECTED\u0026#39;) sleep(0.25) print(f\u0026#39;-- LIFESTEAL ENABLED --{\u0026#34;\\33[0m\u0026#34;}\u0026#39;) sleep(1) def menu_box(): rainbow_colors = [\u0026#34;\\33[91m\u0026#34;, \u0026#34;\\33[33m\u0026#34;, \u0026#34;\\33[92m\u0026#34;,\u0026#34;\\33[34m\u0026#34;, \u0026#34;\\33[36m\u0026#34;, \u0026#34;\\33[95m\u0026#34;] text = \u0026#34;[+ FISTFUL OF DOLLAR]\u0026#34; italy = \u0026#39;\\x1B[3m\u0026#39; r_c = \u0026#34;\\33[0m\u0026#34; colored_text = \u0026#39;\u0026#39;.join(f\u0026#34;{rainbow_colors[i % len(rainbow_colors)]}{italy}{char}{r_c}\u0026#34; for i, char in enumerate(text)) l_pre = \u0026#34;║ 2 - perform_deadcoin \u0026lt;\u0026lt; \u0026#34; l_suf = \u0026#34;║\u0026#34; width = 54 text_width = width - len(l_pre) - len(l_suf) padd = text_width - len(text) res = colored_text + \u0026#39; \u0026#39; * padd box = f\u0026#34;\u0026#34;\u0026#34; ╔════════════════════════════════════════════════════╗ ║ 1 - get_encrypted_flag ║ {l_pre}{res}{l_suf} ║ 3 - call_the_signer ║ ║ 4 - level_restart ║ ║ 5 - level_quit ║ ╚════════════════════════════════════════════════════╝ \u0026#34;\u0026#34;\u0026#34; print(box) def death_message(): print(\u0026#39;\u0026#39;\u0026#39; ▗▖ ▗▖▗▄▖ ▗▖ ▗▖ ▗▄▖ ▗▄▄▖ ▗▄▄▄▖ ▗▄▄▄ ▗▄▄▄▖ ▗▄▖ ▗▄▄▄ ▝▚▞▘▐▌ ▐▌▐▌ ▐▌ ▐▌ ▐▌▐▌ ▐▌▐▌ ▐▌ █ ▐▌ ▐▌ ▐▌▐▌ █ ▐▌ ▐▌ ▐▌▐▌ ▐▌ ▐▛▀▜▌▐▛▀▚▖▐▛▀▀▘ ▐▌ █ ▐▛▀▀▘▐▛▀▜▌▐▌ █ ▐▌ ▝▚▄▞▘▝▚▄▞▘ ▐▌ ▐▌▐▌ ▐▌▐▙▄▄▖ ▐▙▄▄▀ ▐▙▄▄▖▐▌ ▐▌▐▙▄▄▀ ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣤⠴⠶⠶⠶⠶⠶⠶⠶⠶⢤⣤⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⢀⣤⠶⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠛⠶⣤⡀⠀⠀⠀⠀⠀ ⠀⠀⢀⡴⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢷⡄⠀⠀⠀ ⠀⣰⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣦⠀⠀ ⢰⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠹⣧⠀ ⣿⠀⠀⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡄⠀⢹⡄ ⡏⠀⢰⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⢸⡇ ⣿⠀⠘⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡟⠀⢸⡇ ⢹⡆⠀⢹⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠃⠀⣾⠀ ⠈⢷⡀⢸⡇⠀⢀⣠⣤⣶⣶⣶⣤⡀⠀⠀⠀⠀⠀⢀⣠⣶⣶⣶⣶⣤⣄⠀⠀⣿⠀⣼⠃⠀ ⠀⠈⢷⣼⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⡇⠀⢸⡾⠃⠀⠀ ⠀⠀⠈⣿⠀⠀⢿⣿⣿⣿⣿⣿⣿⣿⠁⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⣿⠃⠀⢸⡇⠀⠀⠀ ⠀⠀⠀⣿⠀⠀⠘⢿⣿⣿⣿⣿⡿⠃⠀⢠⠀⣄⠀⠀⠙⢿⣿⣿⣿⡿⠏⠀⠀⢘⡇⠀⠀⠀ ⠀⠀⠀⢻⡄⠀⠀⠀⠈⠉⠉⠀⠀⠀⣴⣿⠀⣿⣷⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⢸⡇⠀⠀⠀ ⠀⠀⠀⠈⠻⣄⡀⠀⠀⠀⠀⠀⠀⢠⣿⣿⠀⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠘⣟⠳⣦⡀⠀⠀⠀⠸⣿⡿⠀⢻⣿⡟⠀⠀⠀⠀⣤⡾⢻⡏⠁⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⢻⡄⢻⠻⣆⠀⠀⠀⠈⠀⠀⠀⠈⠀⠀⠀⢀⡾⢻⠁⢸⠁⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⢸⡇⠀⡆⢹⠒⡦⢤⠤⡤⢤⢤⡤⣤⠤⡔⡿⢁⡇⠀⡿⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠘⡇⠀⢣⢸⠦⣧⣼⣀⡇⢸⢀⣇⣸⣠⡷⢇⢸⠀⠀⡇⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⣷⠀⠈⠺⣄⣇⢸⠉⡏⢹⠉⡏⢹⢀⣧⠾⠋⠀⢠⡇⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠻⣆⠀⠀⠀⠈⠉⠙⠓⠚⠚⠋⠉⠁⠀⠀⠀⢀⡾⠁⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡴⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠳⠶⠦⣤⣤⣤⡤⠶⠞⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀ \u0026#39;\u0026#39;\u0026#39;) RMT.py # class R_MT19937_32bit: def __init__(self, seed=0): self.f = 1812433253 (self.w, self.n, self.m, self.r) = (32, 624, 397, 31) (self.u, self.s, self.t, self.l)= (11, 7, 15, 18) (self.a, self.b, self.c) = (0x9908b0df, 0x9d2c5680, 0xefc60000) (self.lower, self.upper, self.d) = (0x7fffffff, 0x80000000, 0xffffffff) self.MT = [0 for i in range(self.n)] self.seedMT(seed) def seedMT(self, seed): num = seed self.index = self.n for _ in range(0,51): num = 69069 * num + 1 g_prev = num for i in range(self.n): g = 69069 * g_prev + 1 self.MT[i] = g \u0026amp; self.d g_prev = g return self.MT def twist(self): for i in range(0, self.n): x = (self.MT[i] \u0026amp; self.upper) + (self.MT[(i + 1) % self.n] \u0026amp; self.lower) xA = x \u0026gt;\u0026gt; 1 if (x % 2) != 0: xA = xA ^ self.a self.MT[i] = self.MT[(i + self.m) % self.n] ^ xA self.index = 0 def get_num(self): if self.index \u0026gt;= self.n: self.twist() y = self.MT[self.index] y = y ^ ((y \u0026gt;\u0026gt; self.u) \u0026amp; self.d) y = y ^ ((y \u0026lt;\u0026lt; self.s) \u0026amp; self.b) y = y ^ ((y \u0026lt;\u0026lt; self.t) \u0026amp; self.c) y = y ^ (y \u0026gt;\u0026gt; self.l) self.index += 1 return y \u0026amp; ((1 \u0026lt;\u0026lt; self.w) - 1) From the above files we know\nThere is ECDSA happening using secp256k1 curve. The Private Key is generated using a custom prng function called supreme_PRNG(). The Nonce is generated using full_noncense_gen() which internally makes calls to the RMT via sec_real_bits() and partial_noncense_gen(). There is a small perform_deadcoin() mini-game happening where you solve a DLP problem. There is a interface through which we can send JSON encoded \u0026ldquo;routines\u0026rdquo; to perform 5 different actions: get_encrypted_flag -\u0026gt; gives you the AES-CBC encrypted ciphertext and IV. perform_deadcoin -\u0026gt; gives you the chance to heal your HP bar if you solve a DLP problem. call_the_signer -\u0026gt; signs any arbitrary message and returns r and s values along with nonce_gen_consts and heat_gen. level_restart -\u0026gt; lets you restart the level and regenerates the Private Key and seed for the RMT. level_quit -\u0026gt; well duh, let\u0026rsquo;s you quit the connection. RMT which seems to have a different seed initialisation function when compared to python\u0026rsquo;s MT. Analysis # From quite literally glancing through the signing system, we can tell that the nonce generation and private key generation has some inherent bias and moreover the chunks are non-continuous, so we can model the problem as a EHNP instance and perform LLL to solve it.\nBut there seems to be a catch\nelif v1_action == \u0026#34;call_the_signer\u0026#34;: print(LEVEL.call_the_signer()) V1.update(V1.current_health-20) The HP will deteriorate by -20 for every message we sign thus limiting us to two signatures before we can query for the encrypted flag.\nNow to approach the challenge, we need enough HP to sign at least 5 messages before we can find the private key using LLL.\nPRNGS # Let\u0026rsquo;s analyse each of the PRNGS:\nRMT\nThe only difference between python\u0026rsquo;s MT and RMT is the seedMT() function or more popularly called as Ripley\u0026rsquo;s Seeding. This version of MT is used in the programming language R. It uses a 32 bit seed and uses the same 32 bit parameters of a standard MT. seedMT() tries to grow a value and update the internal state of the MT. def seedMT(self, seed): num = seed self.index = self.n for _ in range(0,51): num = 69069 * num + 1 g_prev = num for i in range(self.n): g = 69069 * g_prev + 1 self.MT[i] = g \u0026amp; self.d g_prev = g return self.MT MT is reversible with z3 Solver and as for seedMT() it can also be easily modelled in z3. supreme_RNG()\nIt uses the Middle Square Method to generate the next number. MSM is not cryptographically secure as the generated values will decay and remain stagnant producing a very short cycle. There is also a simple LCG which is used only once per restart as:\ndef privkey_gen(self) -\u0026gt; int: simple_lcg = lambda x: (x * 0xeccd4f4fea74c2b057dafe9c201bae658da461af44b5f04dd6470818429e043d + 0x8aaf15) % self.n if not self.cinit: RNG_seed = simple_lcg(CORE) self.n_gen = self.supreme_RNG(RNG_seed) RNG_gen = next(self.n_gen) self.cinit += 1 else: RNG_gen = next(self.n_gen) ... ... self.cinit = 0 self.d = self.privkey_gen() ... it is only called when self.cinit is 0.\nOther important funcs # perform_deadcoin() as we have previously established, let\u0026rsquo;s you play the mini-game where you solve a DLP problem in-exchange for a 32 bit value from the RMT but there is a hard limit of only being able to play this thrice. Now, after analysing deadcoin_verification() and _dead_coin_params(), the mini-game seems to derive it\u0026rsquo;s exponent from supreme_RNG() which takes its seed from the simple LCG. The simple LCG always produces the value 1569250000 as it is always seeded with CORE and is run only once per level. This value specifically decays to 0 at the 375 cycle. Now let\u0026rsquo;s look at full_noncense_gen()\nIt introduces k_m1, k_m2, k_m3, k_m4 which are cryptographically secure but add bias and k_ and _k which are generated from RMT along with benjamin1, benjamin2 k_ and _k are both 32 bit values and benjamin1 and benjamin2 are 16 bit values. benjamin1 is split into chunks of one byte and is made to be every alternate chunk in the nonce except for the last alternate chunk where 12 lsb of benjamin2 is used. Both the benjamin values are generated by partial_noncense_gen() and are of the form: $$y \\gets b \\ \\oplus (b \\ll s) \\ \\wedge \\ a$$ where $b \\in [0,2^{32}]$ and $y,a \\in [0,2^{16}]$ The full_noncense_gen() also returns n1 and n2 values which are later given as nonce_gen_consts which are equation, _and value from partial_noncense_gen. It also returns cycles which are later given out as heat_gen which denotes the number of calls to RMT before getting the right bit length. In decor.py we can also see that there are no checks on going beyond 100 HP, so we can try to over-heal and get more signatures.\nFrom all the above information, we can formulate our exploit.\nRestart the level 375 times.\nNow the exponent in deadcoin_verification() will be 0 so you can easily pass this check three times and get 3 RMT values and reconstruct the seed using z3 Solver. This also sets your HP to 160.\nNow we sign any arbitrary message five times (our maximum limit) whilst simultaneously accounting for the number of RMT calls from the heat_gen. We can also rebuild both benjamin values using z3 Solver.\nAs there is some bias introduced in the private key, we assign it to the var xbar and also calculate kbar with the appropriate shifts.\nWe can now construct \\(\\pi_{i}\\) and \\(\\nu_{i}\\) from the below equation: $$d \\ = \\ \\bar{d} \\ +\\ \\sum_{j=1}^{m} 2^{\\pi_{j}}d_{j} \\ \\ , \\ \\ 0 \\leq d_{j} \\leq \\ 2^{\\nu_{j}}$$ using the appropriate shifts and bit lengths\nSimilarly we can construct \\(\\lambda_{i,j}\\) and \\(\\mu_{i,j}\\) from the below equation: $$k_{i} = \\bar{k_{i}} +\\sum_{j=1}^{l_{i}}2^{\\lambda_{i,j}}k_{i,j} \\ \\ , \\ \\ 0 \\leq k_{i,j} \u003c 2^{\\mu_{i,j}}$$ using the appropriate shifts and bit lengths given in the code.\nWe can now convert this into a CVP instance and use LLL to solve it to find the private key. The basis: $$B = \\begin{bmatrix}n \\cdot I_{x}\\\\\\ A\u0026X\\\\\\ R\u0026\u0026K \\end{bmatrix}$$Each of the internal matrices can be referred from this amazing paper by Joseph Surin (EHNP part).\nIn essence let $$x = (r_{1},\\dots, r_{x},d_{1},\\dots,d_{m},d_{1,1}\\dots,d_{x,l_{1}},\\dots,d_{x,l_{x}})$$ We would have, $$xB = u$$ $$u =( \\beta_{1} - \\alpha_{1}\\bar{d},\\dots,\\beta_{x} - \\alpha_{x}\\bar{d}, \\frac{d_{1}\\delta}{2^{\\nu_{1}}},\\dots,\\frac{d_{m}\\delta}{2^{\\nu_{m}}}, \\frac{k_{1,1}\\delta}{2^{\\mu_{1,1}}},\\dots,\\frac{k_{1,l_{1}}\\delta}{2^{\\mu_{1,l_{1}}}},\\dots,\\frac{k_{x,1}\\delta}{2^{\\mu_{x,1}}},\\dots,\\frac{k_{x,l_{x}}\\delta}{2^{\\mu_{x,l_{x}}}})$$ So we can let $$w = ( \\beta_{1} - \\alpha_{1}\\bar{d},\\dots,\\beta_{x} - \\alpha_{x}\\bar{d}, \\frac{\\delta}{2},\\dots,\\frac{\\delta}{2}, \\frac{\\delta}{2},\\dots,\\frac{\\delta}{2},\\dots,\\frac{\\delta}{2},\\dots,\\frac{\\delta}{2}$$ as \\(w\\) is close to the lattice vector \\(u\\), therefore solving a CVP instance with \\(w\\) as the target vector may give us lattice vector \\(u\\) which encodes the secret chunks \\(d_{j}\\) in the \\((x+1)^{st}\\) to the \\((x+m)^{th}\\) entries. Note: x and d are interchanged from the paper, d here is the private key and x here is the number of equations. Once the private key is found, we can now send {\u0026quot;event\u0026quot; : \u0026quot;get_encrypted_flag\u0026quot;} and can perform AES-CBC decryption on it, you will be left with 10 HP and you get the flag.\nExploit # Solve.sage # from pwn import * from z3 import * from sage.all import * import json import ast from tqdm import trange from hashlib import sha256 from RMT import R_MT19937_32bit as R_mt class BreakerRipley32: \u0026#34;\u0026#34;\u0026#34; Z3 solver for 32-bit Mersenne Twister with Ripley seeding \u0026#34;\u0026#34;\u0026#34; def __init__(self): (self.w, self.n, self.m, self.r) = (32, 624, 397, 31) self.a = 0x9908B0DF (self.u, self.d) = (11, 0xFFFFFFFF) (self.s, self.b) = (7, 0x9D2C5680) (self.t, self.c) = (15, 0xEFC60000) self.l = 18 self.num_bits = 32 self.lower_mask = (1 \u0026lt;\u0026lt; self.r) - 1 self.upper_mask = 0x80000000 def tamper_state(self, y): y = y ^^ (LShR(y, self.u) \u0026amp; self.d) y = y ^^ ((y \u0026lt;\u0026lt; self.s) \u0026amp; self.b) y = y ^^ ((y \u0026lt;\u0026lt; self.t) \u0026amp; self.c) y = y ^^ LShR(y, self.l) return y def untamper(self, num): def undo_right_shift_xor_and(y, shift, mask): res = y for _ in range(5): res = y ^^ ((res \u0026gt;\u0026gt; shift) \u0026amp; mask) return res def undo_left_shift_xor_and(y, shift, mask): res = y for _ in range(5): res = y ^^ ((res \u0026lt;\u0026lt; shift) \u0026amp; mask) return res y = undo_right_shift_xor_and(num, self.l, 0xFFFFFFFF) y = undo_left_shift_xor_and(y, self.t, self.c) y = undo_left_shift_xor_and(y, self.s, self.b) y = undo_right_shift_xor_and(y, self.u, self.d) return y def twist_state(self, MT): n, m, a = self.n, self.m, self.a lower_mask, upper_mask = self.lower_mask, self.upper_mask new_MT = [BitVec(f\u0026#34;MT_twisted_{i}\u0026#34;, 32) for i in range(n)] for i in range(n): x = (MT[i] \u0026amp; upper_mask) + (MT[(i + 1) % n] \u0026amp; lower_mask) xA = LShR(x, 1) xA = If(x \u0026amp; 1 == 1, xA ^^ a, xA) new_MT[i] = simplify(MT[(i + m) % n] ^^ xA) return new_MT def get_seed_mt(self, outputs): n = self.n SEED = BitVec(\u0026#39;seed\u0026#39;, 32) MT = [BitVec(f\u0026#34;MT_init_{i}\u0026#34;, 32) for i in range(n)] # Ripley seeding (sow and grow seeds) num = SEED for _ in range(51): num = 69069 * num + 1 g_prev = num constraints = [] for i in range(n): g = 69069 * g_prev + 1 constraints.append(MT[i] == (g \u0026amp; 0xFFFFFFFF)) g_prev = g MT_twisted = self.twist_state(MT) S = Solver() S.add(constraints) for idx, value in outputs: S.add(self.tamper_state(MT_twisted[idx]) == value) # Solve for the seed if S.check() == sat: model = S.model() return model[SEED].as_long() else: return None # Quick and reliable load(\u0026#34;https://raw.githubusercontent.com/josephsurin/lattice-based-cryptanalysis/refs/heads/main/lbc_toolkit/common/babai_cvp.sage\u0026#34;) load(\u0026#34;https://raw.githubusercontent.com/josephsurin/lattice-based-cryptanalysis/refs/heads/main/lbc_toolkit/problems/hidden_number_problem.sage\u0026#34;) load(\u0026#34;https://raw.githubusercontent.com/josephsurin/lattice-based-cryptanalysis/refs/heads/main/lbc_toolkit/attacks/ecdsa_key_disclosure.sage\u0026#34;) def json_sender(msg): json_msg = json.dumps(msg).encode() io.sendline(json_msg) def RNG_decayer(): print(f\u0026#34;[{neutral(\u0026#34;*\u0026#34;)}] Restarting enough times to exploit MSM...\u0026#34;) for _ in trange(375): io.recvuntil(routine_pass) json_sender(possible_events[3]) def deadcoin(): print(f\u0026#34;[{neutral(\u0026#34;*\u0026#34;)}] Deadcoining for RMT values...\u0026#34;) RMT_vals = [] for i in range(3): io.recvuntil(routine_pass) json_sender(possible_events[1]) io.recvuntil(b\u0026#39;code: \u0026#39;) json_sender(int(0)) io.recvuntil(b\u0026#39;ID: \u0026#39;) RMT_vals.append((i, int(io.recvline().decode()))) return RMT_vals def partial_nonce_breaker(_and, equation): term = BitVec(\u0026#39;term\u0026#39;, 32) res = term ^^ ((term \u0026lt;\u0026lt; 16) \u0026amp; _and) S = Solver() S.add(res == equation) if S.check() == sat: model = S.model() return model[term].as_long() else: return None def decrypt_flag(d,ciphertext,iv) -\u0026gt; tuple: from Crypto.Cipher import AES from Crypto.Util.Padding import unpad ciphertext=bytes.fromhex(ciphertext) iv = bytes.fromhex(iv) sha2 = sha256() sha2.update(str(d).encode(\u0026#39;ascii\u0026#39;)) key = sha2.digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) plaintext = cipher.decrypt(ciphertext) return plaintext.decode() HOST = \u0026#39;localhost\u0026#39; PORT = 5000 io = remote(HOST, PORT) # Idk man I like pretty printing neutral = lambda text: \u0026#39;\u0026#39;.join(f\u0026#34;{\u0026#34;\\033[92m\u0026#34;}{char}{\u0026#34;\\033[0m\u0026#34;}\u0026#34; for _, char in enumerate(text)) happy = lambda text: \u0026#39;\u0026#39;.join(f\u0026#34;{\u0026#34;\\033[34m\u0026#34;}{char}{\u0026#34;\\033[0m\u0026#34;}\u0026#34; for _, char in enumerate(text)) possible_events = [ {\u0026#39;event\u0026#39;: \u0026#39;get_encrypted_flag\u0026#39;}, {\u0026#39;event\u0026#39;: \u0026#39;perform_deadcoin\u0026#39;}, {\u0026#39;event\u0026#39;: \u0026#39;call_the_signer\u0026#39;}, {\u0026#39;event\u0026#39;: \u0026#39;level_restart\u0026#39;}, {\u0026#39;event\u0026#39;: \u0026#39;level_quit\u0026#39;} ] routine_pass = b\u0026#39;JSON format: \u0026#39; RNG_decayer() outputs = deadcoin() print(outputs) breaker = BreakerRipley32() recovered_seed = breaker.get_seed_mt(outputs) print(\u0026#34;Recovered seed:\u0026#34;, recovered_seed) MT = R_mt(recovered_seed) for _ in range(3): MT.get_num() R = [] S = [] B = [] p_Ki = [] msg = \u0026#34;hello world\u0026#34;.encode() cnt = 5 for _ in range(cnt): io.recvuntil(routine_pass) json_sender(possible_events[2]) io.recvuntil(b\u0026#39;speak? \u0026#39;) io.sendline(msg) sign_res = ast.literal_eval(io.recvline().decode()) R.append(sign_res[\u0026#39;r\u0026#39;]) S.append(sign_res[\u0026#39;s\u0026#39;]) n_gen_const = sign_res[\u0026#39;nonce_gen_consts\u0026#39;] cycles = sign_res[\u0026#39;heat_gen\u0026#39;] ki = [] for i in cycles: for s in range(i): MT.get_num() pk = MT.get_num() ki.append(pk) p_Ki.append(ki) b_buf = [] for i in range(2): _and, equation = n_gen_const[i] b = partial_nonce_breaker(_and, equation) b_buf.append(b) B.append(b_buf) Kbar = [] for b_i, k_i in zip(B,p_Ki): b1,b2 = b_i k1,k2 = k_i Ki = 2^224*(b1 \u0026gt;\u0026gt; 24 \u0026amp; 0xFF) + 2^192*(b1 \u0026gt;\u0026gt; 16 \u0026amp; 0xFF) + 2^160*k1 + 2^152*(b1 \u0026gt;\u0026gt; 8 \u0026amp; 0xFF) + 2^75*(b1 \u0026amp; 0xFF) + 2^33*(b2 \u0026gt;\u0026gt; 24 \u0026amp; 0xFFF) + k2 Kbar.append(Ki) xbar = 0 n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141 Pi = [148,21] # associared with d Nu =[108,107] # associated with d zi = sha256() zi.update(msg) Z = [int(zi.hexdigest(),16) for _ in range(cnt)] Mu = [[24,24,69,30] for _ in range(cnt)] lambdha = [[232,200,83,45] for _ in range(cnt)] d = ecdsa_key_disclosure(xbar, n, Z, R, S, Kbar, Pi, Nu, lambdha, Mu) io.recvuntil(routine_pass) json_sender(possible_events[0]) rec = ast.literal_eval(io.recvline().decode()) ciphertext = rec[\u0026#34;ciphertext\u0026#34;] iv = rec[\u0026#34;iv\u0026#34;] print(f\u0026#39;[{happy(\u0026#34;!\u0026#34;)}] FLAG: {decrypt_flag(d, ciphertext, iv)}\u0026#39;) The flag is bi0sCTF{p4rry_7h15_y0u_f1l7hy_w4r_m4ch1n3}\nAftermath # It looked like the 32 bit seed could be bruteforced and could be solved in an unintended way skipping z3 entirely for the solve (Dorian managed to solve that way) 💀 and Benjamin values not being necessary for the LLL part.\n","date":"13 June 2025","externalUrl":null,"permalink":"/posts/likeprngstoheaven/","section":"Posts","summary":"","title":"bi0sCTF 2025 Crypto ...Like PRNGS to Heaven","type":"posts"},{"content":"Cryptographer at teambi0s, I also like low-level. I just love too many things man..\n","date":"1 January 2025","externalUrl":null,"permalink":"/about/","section":"Aero Blog","summary":"","title":"About me","type":"page"},{"content":" Challenge Description # Here is the admin\u0026#39;s public key: N = b678170a2e2faf2a29d6b236a8508c4a27a828c5c9f40ad467768ef60af30eda4e8596e4cbc3919db6d104ea1155025052918fb8fb3ef78510c6ea41f5be60e26103fb0f36a71883a23027f544b08ad35fc328b184e83f8973695e339d75fe4565e90457f051ba327eb14d77d76fc60b8800e5d04d9407561dc708889ee8b001 e = 010001 Forge a signature to authenticate as admin. Hold on! Let me quickly sign a welcome message for you nc chall.polygl0ts.ch 9024 Source files # cert.py precomputed.py\nSource Analysis # precomputed.py # from Crypto.Util.number import bytes_to_long message = \u0026#34;Sign \\\u0026#34;admin\\\u0026#34; for flag. Cheers, \u0026#34; m = 147375778215096992303698953296971440676323238260974337233541805023476001824 N = 128134160623834514804190012838497659744559662971015449992742073261127899204627514400519744946918210411041809618188694716954631963628028483173612071660003564406245581\u0026gt; e = 65537 signature = 2066100189908203831467740668064384570451707972733136413344205404539358351467797272063760846108596471121604572134007316135429454288237472477734942807611858337\u0026gt; assert(m == bytes_to_long(message.encode())) cert.py # from binascii import hexlify, unhexlify from Crypto.Util.number import bytes_to_long, long_to_bytes from precomputed import message, signature, N, e from flag import flag if __name__ == \u0026#34;__main__\u0026#34;: print(message + hexlify(long_to_bytes(signature)).decode()) cert = input(\u0026#34; \u0026gt; \u0026#34;) try: s = bytes_to_long(unhexlify(cert)) assert(s \u0026lt; N) if pow(s,e,N)==bytes_to_long(\u0026#34;admin\u0026#34;.encode()): print(flag) else: print(\u0026#34;Not admin\u0026#34;) except: print(\u0026#34;Not admin\u0026#34;) We are given a message m, e, N and a signature in precomputed.py and cert.py checks if the signature of \u0026ldquo;admin\u0026rdquo; is sent to the server, if yes, the flag is printed.\nInterestingly: \\(m \\not\\equiv s^e \\bmod N\\) It is not clear for which message this is intended for but since nothing else is provided, it is safe to assume that this is most likely a faulty signature.\nTheory # In the case without fault: $$\\begin{aligned} m^d \u0026\\equiv s \\pmod{N}, \\\\ s^e \u0026\\equiv m \\pmod{N} \\end{aligned}$$In the case of RSA-CRT fault attack:\n$$ \\begin{aligned} \u0026\\text{Let's assume faulty signature to be} \\ \\bar{s}. \\\\ \\\\ \u0026\\begin{cases} \\bar{s}^e = m \\pmod{p} \\\\ \\bar{s}^e \\neq m \\pmod{q} \\end{cases} \\implies \\begin{cases} \\bar{s}^e - m = 0 \\pmod{p} \\\\ \\bar{s}^e - m \\neq 0 \\pmod{q} \\end{cases} \\implies \\begin{cases} (\\bar{s}^e - m)= kp \\\\ (\\bar{s}^e - m) \\not= kq \\end{cases} \\end{aligned} $$This is good for us as we can simply do \\(GCD(s^e - m, N)\\) and that will give us \\(p\\). And with that factorising N becomes trivial.\nSolve script # from math import gcd from Crypto.Util.number import bytes_to_long as b2l from pwn import remote def attack_known_m(n, e, m, s): g = gcd(m - pow(s, e, n), n) return None if g == 1 else (g, n // g) def compPayload(p,q): phi = (p-1)*(q-1) d = pow(e,-1,phi) msg = b2l(b\u0026#39;admin\u0026#39;) payload = pow(msg,d,N) return hex(payload)[2:].encode() HOST = \u0026#39;chall.polygl0ts.ch\u0026#39; PORT = 9024 io = remote(HOST,PORT) m = 147375778215096992303698953296971440676323238260974337233541805023476001824 N = 128134160623834514804190012838497659744559662971015449992742073261127899204627514400519744946918210411041809618188694716954631963628028483173612071660003564406245581\u0026gt; e = 65537 signature = 2066100189908203831467740668064384570451707972733136413344205404539358351467797272063760846108596471121604572134007316135429454288237472477734942807611858337\u0026gt; p,q = attack_known_m(N,e,m,signature) payload = compPayload(p,q) io.sendlineafter(b\u0026#34; \u0026gt; \u0026#34;, payload) print(io.recvline().decode()) # EPFL{Fau17Y_5igNs_Ar3_al!_y0U_ne3D} ","date":"10 December 2024","externalUrl":null,"permalink":"/posts/cert/","section":"Posts","summary":"","title":"LakeCTF 2024 Crypto - Cert","type":"posts"},{"content":" Challenge Description # Can you even sign? Help leo get the flag as soon as possible. nc chall.polygl0ts.ch 9001 Source files # server.py Dockerfile compose.yaml\nSource Analysis # #!/usr/bin/env python3 import os from Crypto.PublicKey import ECC from Crypto.Signature import eddsa flag = os.environ.get(\u0026#34;FLAG\u0026#34;, \u0026#34;EPFL{test_flag}\u0026#34;) msgs = [ b\u0026#34;I, gallileo, command you to give me the flag\u0026#34;, b\u0026#34;Really, give me the flag\u0026#34;, b\u0026#34;can I haz flagg\u0026#34;, b\u0026#34;flag plz\u0026#34; ] leos_key = ECC.generate(curve=\u0026#39;ed25519\u0026#39;) sigs = [ leos_key.public_key().export_key(format=\u0026#39;raw\u0026#39;) + eddsa.new(leos_key, \u0026#39;rfc8032\u0026#39;).sign(msg) for msg in msgs] def parse_and_vfy_sig(sig: bytes, msg: bytes): pk_bytes = sig[:32] sig_bytes = sig[32:] pk = eddsa.import_public_key(encoded=pk_bytes) if pk.pointQ.x == 0: print(\u0026#34;you think you are funny\u0026#34;) raise ValueError(\u0026#34;funny user\u0026#34;) eddsa.new(pk, \u0026#39;rfc8032\u0026#39;).verify(msg, sig_bytes) if __name__ == \u0026#34;__main__\u0026#34;: try: print(\u0026#34;if you really are leo, give me public keys that can verify these signatures\u0026#34;) for msg, sig in zip(msgs, sigs): print(sig[64:].hex()) user_msg = bytes.fromhex(input()) # first 64 bytes encode the public key if len(user_msg) \u0026gt; 64 or len(user_msg) == 0: print(\u0026#34;you\u0026#39;re talking too much, or too little\u0026#34;) exit() to_verif = user_msg + sig[len(user_msg):] parse_and_vfy_sig(to_verif, msg) print(\u0026#34;it\u0026#39;s valid\u0026#34;) except ValueError as e: print(e) exit() print(flag) From the source it is evident that there is EdDSA happening. I just went for the standard Cryptanalysis procedure on this one, that is, to just treat it as a Black-box and observe the outputs.\nSignature generation # sigs = [ leos_key.public_key().export_key(format=\u0026#39;raw\u0026#39;) + eddsa.new(leos_key, \u0026#39;rfc8032\u0026#39;).sign(msg) for msg in msgs] This is of particular interest. It is evident that the signature is for each message is generated by pubkey + actual_sig of the message and also from testing locally we can validate this:\nIn [15]: sigs Out[15]: [b\u0026#34;\\xc6\\xc9]$\\xb2\\xfe}\\xd0\\xde\\xfc\\xf1\\x0fcZ\u0026#39;\\x06!\\xe6\\xa8\\x1f\\x8bSP\\x98\\x17\\xc4\\xd5\\xd9\\xba\\xf8u\\xb8I)2\u0026amp;\\xd4,/\u0026gt;\\x7f\\xc2\\xc8\u0026#39;\\xcaPd\u0026#39;\\r\\xd2I~S\\xd0\\xe2W\\xc5Oq\\xfc\u0026gt;\\x94L\\t\\xbd\\xb9\\x895\\xb4\\xce\\xc1\\xcbF\\xe1\\xce\\x99\\x84c\\x89\\x13\\xb1\\xcbR\\xddY\\t\\x91\\xcdmU\\xe0:\\x9a\\xd83\\x0f\u0026#34;, b\u0026#39;\\xc6\\xc9]$\\xb2\\xfe}\\xd0\\xde\\xfc\\xf1\\x0fcZ\\\u0026#39;\\x06!\\xe6\\xa8\\x1f\\x8bSP\\x98\\x17\\xc4\\xd5\\xd9\\xba\\xf8u\\xb8\\x02\\xfe\\xd5\\xa8\\xcf\\xea\\xf8\\xe3\\xe0\\xbe\\x02\\xc2\\x0f5\\xa1\\x9bE V]\\xfe\\xf7\\xeb6(\\x1c\u0026#34;\\xc6-\\x1aP{\\x1c\\xbb|\\xbd\\xfb\\xa3\\xb67LVc\\xda-\\xa7\\xd3m\\xc1o\\x82\\xd7=\\xd2P\\xa3\\xc6D\\xba\\x93\\xfbD\\xba\\x07\u0026#39;, b\u0026#34;\\xc6\\xc9]$\\xb2\\xfe}\\xd0\\xde\\xfc\\xf1\\x0fcZ\u0026#39;\\x06!\\xe6\\xa8\\x1f\\x8bSP\\x98\\x17\\xc4\\xd5\\xd9\\xba\\xf8u\\xb8\\xb6.\\xee\\nG{\\x14\\xba\u0026#39;\\x94\\xe2\u0026#39;\\xa4\\xbdK\\x98\\xf0\\xa7c3\\xac\\x89\\x7fb\\nmo\\x06\\xe2\\xbf\\xceu\u0026lt;\\xf9\\xe7\\xc2\\xa8/n\\xbf\\xf9O`\\xf9uh\\xa2\\xca\\xf4+\\xa6\\xd5=mY\\x1d\\\\3y2\\x07U\\xad\\x0b\u0026#34;, b\u0026#34;\\xc6\\xc9]$\\xb2\\xfe}\\xd0\\xde\\xfc\\xf1\\x0fcZ\u0026#39;\\x06!\\xe6\\xa8\\x1f\\x8bSP\\x98\\x17\\xc4\\xd5\\xd9\\xba\\xf8u\\xb8Q [\\x9b=\\x83~\\xc56\\xb5^\\x1e\\xdc\\xa5~\\xe9!\\x008HLw\\xf1\\xd5=g\\xdff\\xfa\\x83\\x82D!\\t\\xfa\\xd3\\xd8\\xc1e\\x03!+\\xe3\\xe7\\xe9\\xd4b\\xeb\\x14\\xd7\\xcbN\u0026#39;[|\u0026amp;\\xdf\\xb0\\xddU)$\\xa8\\r\u0026#34;] Main # Contrary to what the challenge requires you to send, that is, the entire pubkey, we can just send part of the pubkey and the remaining will be considered from the pre-existing signature.\nto_verif = user_msg + sig[len(user_msg):] So to make life easier and to pass the verification check from parse_and_vfy_sig() more often, we can send just a single byte to the server and check if it passes the verification check, if not, we close the connection and open an another one and repeat this until the signature verifies.\nThis is feasible as there is a 1/255 chance of us landing on the right byte. \u0026hellip;so there will be a bit of waiting involved.\nNote as the first 32 bytes of every signature is the same, once we hit the right byte, we send it 4 times to the server to pass the verification check completely to get the flag.\nIntended Solve? # Apparently the intended solve required us to find points of low order on this curve but this too works, overall was an easy challenge.\nSolve script # from pwn import * HOST = \u0026#39;chall.polygl0ts.ch\u0026#39; PORT = 9001 context.log_level = \u0026#39;critical\u0026#39; while True: io = remote(HOST,PORT) flag = 0 io.recvline() payload = enhex(b\u0026#39;B\u0026#39;).encode() for t in range(4): io.recvline() io.sendline(payload) server_response = io.recvline().decode().strip() print(server_response) if server_response!=\u0026#34;it\u0026#39;s valid\u0026#34;: break else: print(r) flag = 1 if flag: break io.interactive() # EPFL{wH4T_d0_yOu_m34n_4_W1LdC4Rd} ","date":"10 December 2024","externalUrl":null,"permalink":"/posts/wildsigs/","section":"Posts","summary":"","title":"LakeCTF 2024 Crypto - Wild Signatures","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]